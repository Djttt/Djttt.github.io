{"summary":"<p>AdaGrad算法 (Duchi et al., 2011)通过将粗略的计数器$s(i, t)$<br>替换为先前观察所得梯度的平方之和来解决这个问题。 它使用$s(i, t+1) &#x3D; s(i, t) + (\\partial_i f(\\mathbf{x}))^2$来调整学习率。 这有两个好处：首先，我们不再需要决定梯度何时算足够大。 其次，它会随梯度的大小自动变化。通常对应于较大梯度的坐标会显著缩小，而其他梯度较小的坐标则会得到更平滑的处理。 在实际应用中，它促成了计算广告学及其相关问题中非常有效的优化程序。 但是，它遮盖了AdaGrad固有的一些额外优势，这些优势在预处理环境中很容易被理解。</p>\n<span id=\"more\"></span>\n\n<h2 id=\"1-6-AdaGrad算法\"><a href=\"#1-6-AdaGrad算法\" class=\"headerlink\" title=\"1.6. AdaGrad算法\"></a>1.6. AdaGrad算法</h2><h3 id=\"1-6-1-稀疏特征和学习率\"><a href=\"#1-6-1-稀疏特征和学习率\" class=\"headerlink\" title=\"1.6.1. 稀疏特征和学习率\"></a>1.6.1. 稀疏特征和学习率</h3><p>为了获得良好的准确性，我们大多希望在训练的过程中降低学习率，速度通常为$O(t^{-\\frac{1}{2}})$或更低。</p>\n<p>关于稀疏特征（即只在偶尔出现的特征）的模型训练，这对自然语言来说很常见。 例如，我们看到“预先条件”这个词比“学习”这个词的可能性要小得多。 但是，它在计算广告学和个性化协同过滤等其他领域也很常见。</p>\n<p>只有在这些不常见的特征出现时，与其相关的参数才会得到有意义的更新。 鉴于学习率下降，我们可能最终会面临这样的情况：常见特征的参数相当迅速地收敛到最佳值，而对于不常见的特征，我们仍缺乏足够的观测以确定其最佳值。 换句话说，学习率要么对于常见特征而言降低太慢，要么对于不常见特征而言降低太快。</p>\n<p>解决此问题的一个方法是记录我们看到特定特征的次数，然后将其用作调整学习率。 即我们可以使用大小为$\\eta_i &#x3D; \\frac{\\eta_0}{\\sqrt{s(i, t) + c}}$的学习率，而不是 $\\eta_i &#x3D; \\frac{\\eta_0}{\\sqrt{t+ c}}$。 在这里 $s(i, t)$计下了我们截至$t$时观察到功能$i$的次数。 这其实很容易实施且不产生额外损耗。</p>\n<p>AdaGrad算法 (Duchi et al., 2011)通过将粗略的计数器$s(i, t)$<br>替换为先前观察所得梯度的平方之和来解决这个问题。 它使用$s(i, t+1) &#x3D; s(i, t) + (\\partial_i f(\\mathbf{x}))^2$来调整学习率。 这有两个好处：首先，我们不再需要决定梯度何时算足够大。 其次，它会随梯度的大小自动变化。通常对应于较大梯度的坐标会显著缩小，而其他梯度较小的坐标则会得到更平滑的处理。 在实际应用中，它促成了计算广告学及其相关问题中非常有效的优化程序。 但是，它遮盖了AdaGrad固有的一些额外优势，这些优势在预处理环境中很容易被理解。</p>\n<h3 id=\"1-6-2-算法\"><a href=\"#1-6-2-算法\" class=\"headerlink\" title=\"1.6.2. 算法\"></a>1.6.2. 算法</h3><p>让我们接着上面正式开始讨论。 我们使用变量$\\mathbf{s_t}$来累加过去的梯度方差，如下所示：<br>$$<br>\\mathbf{g_t} &#x3D; \\partial_w l(y_t, f(\\mathbf{x_t, w})), \\<br>$$<br>$$<br>\\mathbf{s_t} &#x3D; \\mathbf{s_{t-1}} + \\mathbf{g_t}^2,<br>$$<br>$$<br>\\mathbf{w_t} &#x3D; \\mathbf{w_{t-1}} - \\frac{\\eta}{\\sqrt{\\mathbf{s_t} + \\epsilon}} \\cdot \\mathbf{g_t}.<br>$$<br>与之前一样，$\\eta$是学习率，<br>$\\epsilon$是一个为维持数值稳定性而添加的常数，用来确保我们不会除以$0$。最后，我们初始化$\\mathbf{s_0} &#x3D; 0$。</p>\n<p>就像在动量法中我们需要跟踪一个辅助变量一样，在AdaGrad算法中，我们允许每个坐标有单独的学习率。 与SGD算法相比，这并没有明显增加AdaGrad的计算代价，因为主要计算用在$\\partial_w l(y_t, f(\\mathbf{x_t, w}))$及其导数。</p>\n<p>眼下让我们先看看它在二次凸问题中的表现如何。 我们仍然以同一函数为例：<br>$$<br>f(\\mathbf{x}) &#x3D; 0.1x_1^2 + 2x_2^2.<br>$$<br>我们将使用与之前相同的学习率来实现AdaGrad算法，即$\\eta &#x3D; 0.4$。可以看到，自变量的迭代轨迹较平滑。 但由于$\\mathbf{s_t}$的累加效果使学习率不断衰减，自变量在迭代后期的移动幅度较小。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">%matplotlib inline</span><br><span class=\"line\"><span class=\"keyword\">import</span> math</span><br><span class=\"line\"><span class=\"keyword\">import</span> torch</span><br><span class=\"line\"><span class=\"keyword\">from</span> d2l <span class=\"keyword\">import</span> torch <span class=\"keyword\">as</span> d2l</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">adagrad_2d</span>(<span class=\"params\">x1, x2, s1, s2</span>):</span><br><span class=\"line\">    eps = <span class=\"number\">1e-6</span></span><br><span class=\"line\">    g1, g2 = <span class=\"number\">0.2</span> * x1, <span class=\"number\">4</span> * x2</span><br><span class=\"line\">    s1 += g1 ** <span class=\"number\">2</span></span><br><span class=\"line\">    s2 += g2 ** <span class=\"number\">2</span></span><br><span class=\"line\">    x1 -= eta / math.sqrt(s1 + eps) * g1</span><br><span class=\"line\">    x2 -= eta / math.sqrt(s2 + eps) * g2</span><br><span class=\"line\">    <span class=\"keyword\">return</span> x1, x2, s1, s2</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">f_2d</span>(<span class=\"params\">x1, x2</span>):</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0.1</span> * x1 ** <span class=\"number\">2</span> + <span class=\"number\">2</span> * x2 ** <span class=\"number\">2</span></span><br><span class=\"line\"></span><br><span class=\"line\">eta = <span class=\"number\">0.4</span></span><br><span class=\"line\">d2l.show_trace_2d(f_2d, d2l.train_2d(adagrad_2d))</span><br></pre></td></tr></table></figure>\n\n<pre><code>epoch 20, x1: -2.382563, x2: -0.158591\n</code></pre>\n<p><img src=\"/2024/10/20/deep-learning-optimizer-6/11_6_4_1.svg\" alt=\"svg\"></p>\n<p>将学习率提高到$2$，可以看到更好的表现。 这已经表明，即使在无噪声的情况下，学习率的降低可能相当剧烈，我们需要确保参数能够适当地收敛。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">eta = <span class=\"number\">2</span></span><br><span class=\"line\">d2l.show_trace_2d(f_2d, d2l.train_2d(adagrad_2d))</span><br></pre></td></tr></table></figure>\n\n<pre><code>epoch 20, x1: -0.002295, x2: -0.000000\n</code></pre>\n<p><img src=\"/2024/10/20/deep-learning-optimizer-6/11_6_6_1.svg\" alt=\"svg\"></p>\n<h3 id=\"1-6-3-从零开始实现\"><a href=\"#1-6-3-从零开始实现\" class=\"headerlink\" title=\"1.6.3. 从零开始实现\"></a>1.6.3. 从零开始实现</h3><p>同动量法一样，AdaGrad算法需要对每个自变量维护同它一样形状的状态变量。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">init_adagrad_states</span>(<span class=\"params\">feature_dim</span>):</span><br><span class=\"line\">    s_w = torch.zeros((feature_dim, <span class=\"number\">1</span>))</span><br><span class=\"line\">    s_b = torch.zeros(<span class=\"number\">1</span>)</span><br><span class=\"line\">    <span class=\"keyword\">return</span> (s_w, s_b)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">adagrad</span>(<span class=\"params\">params, states, hyperparams</span>):</span><br><span class=\"line\">    eps = <span class=\"number\">1e-6</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> p, s <span class=\"keyword\">in</span> <span class=\"built_in\">zip</span>(params, states):</span><br><span class=\"line\">        <span class=\"keyword\">with</span> torch.no_grad():</span><br><span class=\"line\">            s[:] += torch.square(p.grad)</span><br><span class=\"line\">            p[:] -= hyperparams[<span class=\"string\">&#x27;lr&#x27;</span>] * p.grad / torch.sqrt(s + eps)</span><br><span class=\"line\">        p.grad.data.zero_()</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"1-6-4-小结\"><a href=\"#1-6-4-小结\" class=\"headerlink\" title=\"1.6.4. 小结\"></a>1.6.4. 小结</h3><ul>\n<li><p>AdaGrad算法会在单个坐标层面动态降低学习率。</p>\n</li>\n<li><p>AdaGrad算法利用梯度的大小作为调整进度速率的手段：用较小的学习率来补偿带有较大梯度的坐标</p>\n</li>\n<li><p>如果优化问题的结构相当不均匀，AdaGrad算法可以帮助缓解扭曲。</p>\n</li>\n<li><p>在深度学习问题上，AdaGrad算法有时在降低学习率方面可能过于剧烈。</p>\n</li>\n</ul>\n"}